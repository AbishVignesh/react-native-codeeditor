{
  "messageport-dispatcher.min.js": "!function(e,t){\"object\"==typeof exports&&\"undefined\"!=typeof module?t(exports):\"function\"==typeof define&&define.amd?define([\"exports\"],t):t(e.MessagePortDispatcher={})}(this,function(e){\"use strict\";function t(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,\"default\")?e.default:e}function s(e,t){return e(t={exports:{}},t.exports),t.exports}var r=s(function(e,t){Object.defineProperty(t,\"__esModule\",{value:!0});const s=(e=>(t,s)=>Boolean(t&&e.call(t,s)))(Object.prototype.hasOwnProperty);t.hasOwn=s,t.default=s}),n=t(r),i=(r.hasOwn,s(function(e,t){Object.defineProperty(t,\"__esModule\",{value:!0});var s,n=(s=r)&&\"object\"==typeof s&&\"default\"in s?s.default:s;const i=e=>\"object\"==typeof e&&null!==e;class o{constructor(e,t=null){this.type=e,this.data=t,this.defaultPrevented=!1}toJSON(){return{type:this.type,data:this.data}}isDefaultPrevented(){return this.defaultPrevented}preventDefault(){this.defaultPrevented=!0}}const a=(e,t)=>{let s=e;return i(e)||(s=new o(String(e),t)),s};class h{constructor(e,t,s){this.index=-1,this.immediatelyStopped=!1,this.stopImmediatePropagation=(()=>{this.immediatelyStopped=!0}),this.listeners=e,this.onStopped=t,this.onComplete=s}run(e,t){let s;const{listeners:r}=this;for(this.augmentEvent(e),this.index=0;this.index<r.length&&!this.immediatelyStopped;this.index++)(s=r[this.index]).call(t,e);this.clearEvent(e),this.onComplete(this)}augmentEvent(e){const t=e;t.stopPropagation=this.onStopped,t.stopImmediatePropagation=this.stopImmediatePropagation}clearEvent(e){const t=e;delete t.stopPropagation,delete t.stopImmediatePropagation}listenerRemoved(e,t){e===this.listeners&&t<=this.index&&this.index--}}class c{constructor(){this._listeners={},this._runners=[],this.removeRunner=(e=>{this._runners.splice(this._runners.indexOf(e),1)})}createList(e,t){const s=parseInt(t,10),r=this.getPrioritiesByKey(e),i=String(s);let o;return n(r,i)?o=r[i]:(o=[],r[i]=o),o}getPrioritiesByKey(e){let t;return n(this._listeners,e)?t=this._listeners[e]:(t={},this._listeners[e]=t),t}add(e,t,s){const r=this.createList(e,s);r.indexOf(t)<0&&r.push(t)}has(e){let t,s=!1;const r=this.getPrioritiesByKey(e);if(r)for(t in r)if(n(r,t)){s=!0;break}return s}remove(e,t){const s=this.getPrioritiesByKey(e);if(s){const e=Object.getOwnPropertyNames(s),{length:r}=e;for(let n=0;n<r;n++){const r=e[n],i=s[r],o=i.indexOf(t);o>=0&&(i.splice(o,1),i.length||delete s[r],this._runners.forEach(e=>{e.listenerRemoved(i,o)}))}}}removeAll(e){delete this._listeners[e]}createRunner(e,t){const s=new h(e,t,this.removeRunner);return this._runners.push(s),s}call(e,t){const s=this.getPrioritiesByKey(e.type);let r=!1;const n=()=>{r=!0};if(s){const i=Object.getOwnPropertyNames(s).sort((e,t)=>e-t),{length:o}=i;for(let a=0;a<o&&!r;a++){const r=s[i[a]];if(r){const s=this.createRunner(r,n);if(s.run(e,t),s.immediatelyStopped)break}}}}}class l{constructor(e=null){this._eventPreprocessor=e,this._listeners=new c}addEventListener(e,t,s=0){this._listeners.add(e,t,-s||0)}hasEventListener(e){return this._listeners.has(e)}removeEventListener(e,t){this._listeners.remove(e,t)}removeAllEventListeners(e){this._listeners.removeAll(e)}dispatchEvent(e,t){let s=a(e,t);this._eventPreprocessor&&(s=this._eventPreprocessor.call(this,s)),this._listeners.call(s)}}t.default=l,t.Event=o,t.EventDispatcher=l,t.createEventDispatcher=(e=>new l(e)),t.getEvent=a,t.isObject=i}));t(i);i.Event,i.EventDispatcher;var o=i.createEventDispatcher,a=i.getEvent,h=i.isObject;const c=()=>`MP/${Math.ceil(1e4*Math.random())}/${Date.now()}`,l=e=>\"function\"==typeof e.toJSON?e.toJSON():JSON.stringify(e),d=e=>{if(h(e))return e;try{return JSON.parse(e)}catch(e){}};class p{constructor(e,t){this.event=e,this.dispatcherId=t}toJSON(){return{event:l(this.event),dispatcherId:this.dispatcherId}}}const u=e=>{const t=d(e);if(t&&(e=>h(e)&&n(e,\"dispatcherId\")&&n(e,\"event\"))(t)){const{event:e,dispatcherId:s}=t;return new p(d(e),s)}return null};class v{constructor(e=null,t=null,s=null,r=null){this.dispatcherId=c(),this.targetOrigin=\"*\",this.target=e||self,this.customPostMessageHandler=t,this.senderEventPreprocessor=r,this.sender=o(),this.receiver=o(s),this.target.addEventListener(\"message\",e=>this._postMessageListener(e))}addEventListener(e,t,s){this.receiver.addEventListener(e,t,s)}hasEventListener(e){return this.receiver.hasEventListener(e)}removeEventListener(e,t){this.receiver.removeEventListener(e,t)}removeAllEventListeners(e){this.receiver.removeAllEventListeners(e)}dispatchEvent(e,t,s){let r=a(e,t);this.senderEventPreprocessor&&(r=this.senderEventPreprocessor.call(this,r));const n=l(new p(r,this.dispatcherId));return this._postMessageHandler(n,s)}_postMessageHandler(e,t){const s=this.customPostMessageHandler;return s?s.call(this,e,this.targetOrigin,t):this.target.postMessage(e,this.targetOrigin,t)}_postMessageListener(e){e=e.nativeEvent||e;const t=u(e.data);t&&(t.dispatcherId===this.dispatcherId?this.sender.dispatchEvent(t.event):this.receiver.dispatchEvent(t.event))}}const f=(e,t,s,r)=>new v(e,t,s,r),g=(e,t=null)=>()=>(t||(t=f(e())),t),m=g(()=>self),y=g(()=>parent),P=g(()=>top);e.default=v,e.MessagePortDispatcher=v,e.MessagePortEvent=p,e.factory=g,e.getForSelf=m,e.getForParent=y,e.getForTop=P,e.createMessagePortDispatcher=f,Object.defineProperty(e,\"__esModule\",{value:!0})});\n//# sourceMappingURL=messageport-dispatcher.min.js.map\n",
  "editor.html": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Code Editor</title>\n    <style type=\"text/css\">\n\t\thtml, body {\n\t\t\tmargin: 0;\n\t\t\tpadding: 0;\n\t\t\twidth: 100%;\n\t\t\theight: 100%;\n\t\t}\n        /*#${rn-webview-editor-css}#*/\n    </style>\n    <script type=\"text/javascript\">\n        /*#${rn-webview-editor-js}#*/\n    </script>\n</head>\n<body>\n</body>\n</html>\n",
  "initscript.js": "const { createMessagePortDispatcher } = MessagePortDispatcher;\n\nlet _initializeId;\nlet editor = null;\n\nconst augmentData = (data) => ({\n  meta: {\n    historySize: editor ? editor.historySize() : null,\n  },\n  data,\n});\n\nconst augmentEvent = ({ type, data }) => ({\n  type,\n  data: augmentData(data),\n});\n\nconst dispatcherTarget = {\n  postMessage: (data) => {\n    window.ReactNativeWebView && window.ReactNativeWebView.postMessage(JSON.stringify(data));\n  },\n  addEventListener: (eventType, listener) => {\n    document.addEventListener(eventType, listener);\n    window.addEventListener(eventType, listener);\n  },\n};\n\nconst dispatcher = createMessagePortDispatcher(dispatcherTarget, null, null, augmentEvent);\n\nwindow.onerror = (message, source, lineno, colno, error) => {\n  const data = { message: String(message), source, lineno, colno };\n\n  if (error) {\n    data.error = Object.assign({}, error);\n  }\n\n  dispatcher.dispatchEvent('wvGlobalError', data);\n};\n\nwindow.log = (...message) => {\n  dispatcher.dispatchEvent('wvLog', message);\n};\n\n/**\n * Generate API event request/response pair\n * @param {*} type\n * @param {*} handler\n * @param {*} responseType\n */\nconst listenForAPIEvent = (type, handler, responseType) =>\n  dispatcher.addEventListener(type, (event) => {\n    if (responseType === undefined) {\n      responseType = `${type}Response`;\n    }\n\n    const result = handler(event);\n\n    if (responseType) {\n      dispatcher.dispatchEvent(responseType, result);\n    }\n  });\n\nconst setEditorSettings = (settings) =>\n  Object.keys(settings).forEach((key) => {\n    editor.setOption(key, settings[key]);\n  });\n\n/**\n * Initialize all API event listeners\n */\nconst initEventListeners = (autoUpdateInterval) => {\n  listenForAPIEvent('setValue', (event) => {\n    editor.setValue(event.data);\n  });\n\n  listenForAPIEvent('getValue', () => editor.getValue());\n\n  listenForAPIEvent('resetValue', (event) => {\n\n    editor.setValue(event.data);\n\n    editor.clearHistory();\n\n  });\n\n  listenForAPIEvent('focus', () => editor.focus());\n\n  listenForAPIEvent('getSelection', () => editor.getSelection());\n\n  listenForAPIEvent('replaceSelection', (event) => editor.replaceSelection(event.data));\n\n listenForAPIEvent('historyUndo', () => {\n    editor.undo();\n  });\n\n  listenForAPIEvent('execCommand', ({ data: { command, args = [] } }) => {\n    editor.execCommand(command, ...args);\n  });\n\n  listenForAPIEvent('historyRedo', () => {\n    editor.redo();\n  });\n\n  listenForAPIEvent('historyClear', () => {\n    editor.clearHistory();\n  });\n\n  listenForAPIEvent('historyRead', () => editor.getHistory());\n\n  listenForAPIEvent('historyWrite', (event) => {\n    editor.setHistory(event.data);\n  });\n\n  listenForAPIEvent('historySize', () => editor.historySize());\n\n  listenForAPIEvent('scrollToCursor', (event) => {\n    const margin = event.data;\n\n    editor.scrollIntoView(null, margin);\n  });\n\n  listenForAPIEvent('updateSettings', (event) => {\n    const settings = event.data;\n\n    setEditorSettings(settings);\n  });\n\n  listenForAPIEvent(\n    'handshake',\n    ({ data }) => {\n      clearInterval(_initializeId);\n\n      if (!data) {\n        return;\n      }\n\n      const { content = '', history, settings } = data;\n\n      editor.setValue(content);\n\n      if (history) {\n        editor.setHistory(history);\n      } else {\n        editor.clearHistory();\n      }\n\n      if (settings) {\n        setEditorSettings(settings);\n      }\n    },\n    'initialized',\n  );\n\n  let waitingForUpdate = false;\n\n  if (autoUpdateInterval) {\n    editor.on('change', () => {\n      if (!waitingForUpdate) {\n        waitingForUpdate = true;\n\n        setTimeout(() => {\n          waitingForUpdate = false;\n          dispatcher.dispatchEvent('autoUpdate', editor.getValue());\n        }, autoUpdateInterval);\n      }\n    });\n  }\n};\n\n/**\n * Entry point of WebView code editor, inits API and starts handshake\n * @param {*} settings\n */\nconst runEditor = (settings, autoUpdateInterval = 0) => {\n  editor = new CodeMirror(document.body, settings);\n  editor.setSize('100%', '100%');\n\n  initEventListeners(autoUpdateInterval);\n\n  _initializeId = setInterval(() => dispatcher.dispatchEvent('initialize'), 500);\n};\n"
}